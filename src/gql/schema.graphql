schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
"The `BigInt` scalar type represents non-fractional signed whole numeric values."
scalar BigInt
scalar CanvasConfig
"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime
scalar DeploymentMeta
scalar DisplayConfig
scalar EventProperties
"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON
scalar SerializedTemplateConfig
scalar ServiceInstanceLimit
"""
The ServiceVariables scalar type represents values as the TypeScript type: Record<string, string>. Example: "{ foo: 'bar', baz: 'qux' }"
"""
scalar ServiceVariables
scalar SubscriptionPlanLimit
scalar TemplateConfig
scalar TemplateMetadata
scalar TemplateServiceConfig
scalar TemplateVolume
"The `Upload` scalar type represents a file upload."
scalar Upload
type AccessRule {
  disallowed: String
}
type AdoptionInfo implements Node {
  adoptionLevel: Float
  createdAt: DateTime!
  customer: Team!
  deltaLevel: Float
  id: ID!
  matchedIcpEmail: String
  monthlyEstimatedUsage: Float
  numConfigFile: Int!
  numCronSchedule: Int!
  numDeploys: Int!
  numEnvs: Int!
  numFailedDeploys: Int!
  numHealthcheck: Int!
  numIconConfig: Int!
  numRegion: Int!
  numReplicas: Int!
  numRootDirectory: Int!
  numSeats: Int!
  numServices: Int!
  numSupportRequests: Int!
  numVariables: Int!
  numWatchPatterns: Int!
  totalCores: Float
  totalDisk: Float
  totalNetwork: Float
  updatedAt: DateTime!
}
"The aggregated usage of a single measurement."
type AggregatedUsage {
  "The measurement that was aggregated."
  measurement: MetricMeasurement!
  "The tags that were used to group the metric. Only the tags that were used in the `groupBy` will be present."
  tags: MetricTags!
  "The aggregated value."
  value: Float!
}
type AllDomains {
  customDomains: [CustomDomain!]!
  serviceDomains: [ServiceDomain!]!
}
type ApiToken implements Node {
  displayToken: String!
  id: ID!
  name: String!
  teamId: String
}
type BanReasonHistory implements Node {
  actor: User!
  banReason: String
  createdAt: DateTime!
  id: ID!
}
"The billing period for a customers subscription."
type BillingPeriod {
  end: DateTime!
  start: DateTime!
}
type CertificatePublicData {
  domainNames: [String!]!
  expiresAt: DateTime
  fingerprintSha256: String!
  issuedAt: DateTime
  keyType: KeyType!
}
type CnameCheck {
  link: String
  message: String!
  status: CnameCheckStatus!
}
type Container implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  environment: Environment!
  environmentId: String!
  id: ID!
  migratedAt: DateTime
  plugin: Plugin!
  pluginId: String!
}
type Credit implements Node {
  amount: Float!
  createdAt: DateTime!
  customerId: String!
  id: ID!
  memo: String
  type: CreditType!
  updatedAt: DateTime!
}
type CreditTransferMetrics {
  creditTransferAvg: Float
  creditTransferCount: Int
  creditTransferSum: Int
}
type CustomDomain implements Domain {
  cnameCheck: CnameCheck! @deprecated(reason: "Use the `status` field instead.")
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  status: CustomDomainStatus!
  targetPort: Int
  updatedAt: DateTime
}
type CustomDomainStatus {
  cdnProvider: CDNProvider
  certificateStatus: CertificateStatus!
  certificates: [CertificatePublicData!]
  dnsRecords: [DNSRecords!]!
}
type Customer implements Node {
  appliedCredits: Float!
  billingEmail: String
  billingPeriod: BillingPeriod!
  creditBalance: Float!
  credits(after: String, before: String, first: Int, last: Int): CustomerCreditsConnection!
  defaultPaymentMethod: PaymentMethod
  defaultPaymentMethodId: String
  id: ID!
  invoices: [CustomerInvoice!]!
  isPrepaying: Boolean!
  isTrialing: Boolean!
  isUsageSubscriber: Boolean!
  isWithdrawingToCredits: Boolean!
  planLimitOverride: PlanLimitOverride
  remainingUsageCreditBalance: Float!
  state: SubscriptionState!
  stripeCustomerId: String!
  subscriptions: [CustomerSubscription!]!
  teamId: String
  usageLimit: UsageLimit
  userId: String
}
type CustomerCreditsConnection {
  edges: [CustomerCreditsConnectionEdge!]!
  pageInfo: PageInfo!
}
type CustomerCreditsConnectionEdge {
  cursor: String!
  node: Credit!
}
type CustomerInvoice {
  amountPaid: Float!
  hostedURL: String
  invoiceId: String!
  items: [SubscriptionItem!]!
  paymentIntentStatus: String
  pdfURL: String
  periodEnd: String!
  periodStart: String!
  status: String
  subscriptionId: String
  total: Int!
}
type CustomerSubscription {
  billingCycleAnchor: DateTime!
  cancelAt: String
  cancelAtPeriodEnd: Boolean!
  couponId: String
  discounts: [SubscriptionDiscount!]!
  id: String!
  items: [SubscriptionItem!]!
  latestInvoiceId: String!
  nextInvoiceCurrentTotal: Int!
  nextInvoiceDate: String!
  status: String!
}
type DNSRecords {
  currentValue: String!
  fqdn: String!
  hostlabel: String!
  purpose: DNSRecordPurpose!
  recordType: DNSRecordType!
  requiredValue: String!
  status: DNSRecordStatus!
  zone: String!
}
type Deployment implements Node {
  canRedeploy: Boolean!
  canRollback: Boolean!
  createdAt: DateTime!
  creator: User
  environment: Environment!
  environmentId: String!
  id: ID!
  meta: DeploymentMeta
  projectId: String!
  service: Service!
  serviceId: String
  snapshotId: String
  sockets: [DeploymentSocket!]!
  staticUrl: String
  status: DeploymentStatus!
  suggestAddServiceDomain: Boolean!
  updatedAt: DateTime!
  url: String
}
type DeploymentEvent implements Node {
  completedAt: DateTime
  createdAt: DateTime!
  id: ID!
  payload: DeploymentEventPayload
  step: DeploymentEventStep!
}
type DeploymentEventPayload {
  error: String
}
type DeploymentSnapshot implements Node {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  variables: ServiceVariables!
}
type DeploymentSocket {
  ipv6: Boolean!
  port: Int!
  processName: String!
  updatedAt: Int!
}
type DeploymentTrigger implements Node {
  baseEnvironmentOverrideId: String
  branch: String!
  checkSuites: Boolean!
  environmentId: String!
  id: ID!
  projectId: String!
  provider: String!
  repository: String!
  serviceId: String
  validCheckSuites: Int!
}
type DomainAvailable {
  available: Boolean!
  message: String!
}
type DomainWithStatus {
  cdnProvider: CDNProvider
  certificateStatus: CertificateStatus!
  certificates: [CertificatePublicData!]
  dnsRecords: [DNSRecords!]!
  domain: Domain
}
type EgressGateway {
  ipv4: String!
  region: String!
}
type Environment implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deploymentTriggers(after: String, before: String, first: Int, last: Int): EnvironmentDeploymentTriggersConnection!
  deployments(after: String, before: String, first: Int, last: Int): EnvironmentDeploymentsConnection!
  id: ID!
  isEphemeral: Boolean!
  meta: EnvironmentMeta
  name: String!
  projectId: String!
  serviceInstances(after: String, before: String, first: Int, last: Int): EnvironmentServiceInstancesConnection!
  sourceEnvironment: Environment
  unmergedChangesCount: Int
  updatedAt: DateTime!
  variables(after: String, before: String, first: Int, last: Int): EnvironmentVariablesConnection!
  volumeInstances(after: String, before: String, first: Int, last: Int): EnvironmentVolumeInstancesConnection!
}
type EnvironmentDeploymentTriggersConnection {
  edges: [EnvironmentDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}
type EnvironmentDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}
type EnvironmentDeploymentsConnection {
  edges: [EnvironmentDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}
type EnvironmentDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}
type EnvironmentMeta {
  baseBranch: String
  branch: String
  prCommentId: Int
  prNumber: Int
  prRepo: String
  prTitle: String
}
type EnvironmentServiceInstancesConnection {
  edges: [EnvironmentServiceInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}
type EnvironmentServiceInstancesConnectionEdge {
  cursor: String!
  node: ServiceInstance!
}
type EnvironmentVariablesConnection {
  edges: [EnvironmentVariablesConnectionEdge!]!
  pageInfo: PageInfo!
}
type EnvironmentVariablesConnectionEdge {
  cursor: String!
  node: Variable!
}
type EnvironmentVolumeInstancesConnection {
  edges: [EnvironmentVolumeInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}
type EnvironmentVolumeInstancesConnectionEdge {
  cursor: String!
  node: VolumeInstance!
}
"The estimated usage of a single measurement."
type EstimatedUsage {
  "The estimated value."
  estimatedValue: Float!
  "The measurement that was estimated."
  measurement: MetricMeasurement!
  projectId: String!
}
type Event implements Node {
  action: String!
  createdAt: DateTime!
  environment: Environment
  environmentId: String
  id: ID!
  object: String!
  payload: JSON
  project: Project!
  projectId: String!
}
type GitHubAccess {
  hasAccess: Boolean!
  isPublic: Boolean!
}
type GitHubBranch {
  name: String!
}
type GitHubRepo {
  defaultBranch: String!
  fullName: String!
  id: Int!
  installationId: String!
  isPrivate: Boolean!
  name: String!
}
type HerokuApp {
  id: String!
  name: String!
}
type Incident {
  id: String!
  message: String!
  status: IncidentStatus!
  url: String!
}
type Integration implements Node {
  config: JSON!
  id: ID!
  name: String!
  projectId: String!
}
type IntegrationAuth implements Node {
  id: ID!
  integrations(after: String, before: String, first: Int, last: Int): IntegrationAuthIntegrationsConnection!
  provider: String!
  providerId: String!
}
type IntegrationAuthIntegrationsConnection {
  edges: [IntegrationAuthIntegrationsConnectionEdge!]!
  pageInfo: PageInfo!
}
type IntegrationAuthIntegrationsConnectionEdge {
  cursor: String!
  node: Integration!
}
type InviteCode implements Node {
  code: String!
  createdAt: DateTime!
  id: ID!
  project: Project!
  projectId: String!
  role: ProjectRole!
}
"The result of a logs query."
type Log {
  "The attributes that were parsed from a structured log"
  attributes: [LogAttribute!]!
  "The contents of the log message"
  message: String!
  "The severity of the log message (eg. err)"
  severity: String
  "The tags that were associated with the log"
  tags: LogTags
  "The timestamp of the log message in format RFC3339 (nano)"
  timestamp: String!
}
"The attributes associated with a structured log"
type LogAttribute {
  key: String!
  value: String!
}
"The tags associated with a specific log"
type LogTags {
  deploymentId: String
  deploymentInstanceId: String
  environmentId: String
  pluginId: String
  projectId: String
  serviceId: String
  snapshotId: String
}
type Maintenance {
  id: String!
  message: String!
  status: MaintenanceStatus!
  url: String!
}
"A single sample of a metric."
type Metric {
  "The timestamp of the sample. Represented has number of seconds since the Unix epoch."
  ts: Int!
  "The value of the sample."
  value: Float!
}
"The tags that were used to group the metric."
type MetricTags {
  deploymentId: String
  environmentId: String
  pluginId: String
  projectId: String
  serviceId: String
  volumeId: String
}
"The result of a metrics query."
type MetricsResult {
  "The measurement of the metric."
  measurement: MetricMeasurement!
  "The tags that were used to group the metric. Only the tags that were used to by will be present."
  tags: MetricTags!
  "The samples of the metric."
  values: [Metric!]!
}
type Mutation {
  "Creates a new API token."
  apiTokenCreate(input: ApiTokenCreateInput!): String!
  "Deletes an API token."
  apiTokenDelete(id: String!): Boolean!
  "Sets the base environment override for a deployment trigger."
  baseEnvironmentOverride(id: String!, input: BaseEnvironmentOverrideInput!): Boolean!
  "Creates a new custom domain."
  customDomainCreate(input: CustomDomainCreateInput!): CustomDomain!
  "Deletes a custom domain."
  customDomainDelete(id: String!): Boolean!
  "Updates a custom domain."
  customDomainUpdate(environmentId: String!, id: String!, targetPort: Int): Boolean!
  "Migrate a customer to the hobby plan"
  customerMigrateToHobbyPlan(id: String!): Boolean!
  "Toggle whether a customer is automatically withdrawing to credits"
  customerTogglePayoutsToCredits(customerId: String!, input: customerTogglePayoutsToCreditsInput!): Boolean!
  "Cancels a deployment."
  deploymentCancel(id: String!): Boolean!
  "Redeploys a deployment."
  deploymentRedeploy(id: String!, usePreviousImageTag: Boolean): Deployment!
  "Removes a deployment."
  deploymentRemove(id: String!): Boolean!
  "Restarts a deployment."
  deploymentRestart(id: String!): Boolean!
  "Rolls back to a deployment."
  deploymentRollback(id: String!): Boolean!
  "Creates a deployment trigger."
  deploymentTriggerCreate(input: DeploymentTriggerCreateInput!): DeploymentTrigger!
  "Deletes a deployment trigger."
  deploymentTriggerDelete(id: String!): Boolean!
  "Updates a deployment trigger."
  deploymentTriggerUpdate(id: String!, input: DeploymentTriggerUpdateInput!): DeploymentTrigger!
  "Create a new egress gateway association for a service instance"
  egressGatewayAssociationCreate(input: EgressGatewayCreateInput!): [EgressGateway!]!
  "Clear all egress gateway associations for a service instance"
  egressGatewayAssociationsClear(input: EgressGatewayServiceTargetInput!): Boolean!
  "Change the User's account email if there is a valid change email request."
  emailChangeConfirm(nonce: String!): Boolean!
  "Initiate an email change request for a user"
  emailChangeInitiate(newEmail: String!): Boolean!
  "Creates a new environment."
  environmentCreate(input: EnvironmentCreateInput!): Environment!
  "Deletes an environment."
  environmentDelete(id: String!): Boolean!
  "Renames an environment."
  environmentRename(id: String!, input: EnvironmentRenameInput!): Environment!
  "Deploys all connected triggers for an environment."
  environmentTriggersDeploy(input: EnvironmentTriggersDeployInput!): Boolean!
  "Track a batch of events for authenticated user"
  eventBatchTrack(input: EventBatchTrackInput!): Boolean!
  "Track event for authenticated user"
  eventTrack(input: EventTrackInput!): Boolean!
  "Agree to the fair use policy for the currently authenticated user"
  fairUseAgree(agree: Boolean!): Boolean!
  "Add a feature flag for a user"
  featureFlagAdd(input: FeatureFlagToggleInput!): Boolean!
  "Remove a feature flag for a user"
  featureFlagRemove(input: FeatureFlagToggleInput!): Boolean!
  "Deploys a GitHub repo"
  githubRepoDeploy(input: GitHubRepoDeployInput!): Boolean!
  "Updates a GitHub repo through the linked template"
  githubRepoUpdate(input: GitHubRepoUpdateInput!): Boolean!
  "Creates a new help station thread"
  helpStationCreateThread(input: HelpStationFormInput!): String!
  "Import variables from a Heroku app into a Railway service. Returns the number of variables imports"
  herokuImportVariables(input: HerokuImportVariablesInput!): Int!
  "Create an integration for a project"
  integrationCreate(input: IntegrationCreateInput!): Integration!
  "Delete an integration for a project"
  integrationDelete(id: String!): Boolean!
  "Update an integration for a project"
  integrationUpdate(id: String!, input: IntegrationUpdateInput!): Integration!
  "Join a project using an invite code"
  inviteCodeUse(code: String!): Project!
  "Creates a new job application."
  jobApplicationCreate(input: JobApplicationCreateInput!, resume: Upload!): Boolean!
  "Auth a login session for a user"
  loginSessionAuth(input: LoginSessionAuthInput!): Boolean!
  "Cancel a login session"
  loginSessionCancel(code: String!): Boolean!
  "Get a token for a login session if it exists"
  loginSessionConsume(code: String!): String
  "Start a CLI login session"
  loginSessionCreate: String!
  "Verify if a login session is valid"
  loginSessionVerify(code: String!): Boolean!
  "Deletes session for current user if it exists"
  logout: Boolean!
  "Alert the team of a missing command palette command"
  missingCommandAlert(input: MissingCommandAlertInput!): Boolean!
  "Create an observability dashboard"
  observabilityDashboardCreate(input: ObservabilityDashboardCreateInput!): Boolean!
  "Reset an observability dashboard to default dashboard items"
  observabilityDashboardReset(id: String!): Boolean!
  "Update an observability dashboard"
  observabilityDashboardUpdate(id: String!, input: [ObservabilityDashboardUpdateInput!]!): Boolean!
  "Creates a new plugin."
  pluginCreate(input: PluginCreateInput!): Plugin! @deprecated(reason: "Plugins are deprecated on Railway. Use database templates instead.")
  "Deletes a plugin."
  pluginDelete(environmentId: String, id: String!): Boolean!
  "Reset envs and container for a plugin in an environment"
  pluginReset(id: String!, input: ResetPluginInput!): Boolean!
  "Resets the credentials for a plugin in an environment"
  pluginResetCredentials(id: String!, input: ResetPluginCredentialsInput!): String!
  "Restarts a plugin."
  pluginRestart(id: String!, input: PluginRestartInput!): Plugin!
  "Force start a plugin"
  pluginStart(id: String!, input: PluginRestartInput!): Boolean!
  "Updates an existing plugin."
  pluginUpdate(id: String!, input: PluginUpdateInput!): Plugin!
  "Update the email preferences for a user"
  preferencesUpdate(input: PreferencesUpdateData!): Preferences!
  "Create or get a private network."
  privateNetworkCreateOrGet(input: PrivateNetworkCreateOrGetInput!): PrivateNetwork!
  "Create or get a private network endpoint."
  privateNetworkEndpointCreateOrGet(input: PrivateNetworkEndpointCreateOrGetInput!): PrivateNetworkEndpoint!
  "Delete a private network endpoint."
  privateNetworkEndpointDelete(id: String!): Boolean!
  "Rename a private network endpoint."
  privateNetworkEndpointRename(dnsName: String!, id: String!, privateNetworkId: String!): Boolean!
  "Delete all private networks for an environment."
  privateNetworksForEnvironmentDelete(environmentId: String!): Boolean!
  "Claims a project."
  projectClaim(id: String!): Project!
  "Creates a new project."
  projectCreate(input: ProjectCreateInput!): Project!
  "Deletes a project."
  projectDelete(id: String!): Boolean!
  "Accept a project invitation using the invite code"
  projectInvitationAccept(code: String!): ProjectPermission!
  "Create an invitation for a project"
  projectInvitationCreate(id: String!, input: ProjectInvitee!): ProjectInvitation!
  "Delete an invitation for a project"
  projectInvitationDelete(id: String!): Boolean!
  "Resend an invitation for a project"
  projectInvitationResend(id: String!): ProjectInvitation!
  "Invite a user by email to a project"
  projectInviteUser(id: String!, input: ProjectInviteUserInput!): Boolean!
  "Leave project as currently authenticated user"
  projectLeave(id: String!): Boolean!
  "Remove user from a project"
  projectMemberRemove(input: ProjectMemberRemoveInput!): [ProjectMember!]!
  "Change the role for a user within a project"
  projectMemberUpdate(input: ProjectMemberUpdateInput!): ProjectMember!
  "Create a token for a project that has access to a specific environment"
  projectTokenCreate(input: ProjectTokenCreateInput!): String!
  "Delete a project token"
  projectTokenDelete(id: String!): Boolean!
  "Confirm the transfer of project ownership"
  projectTransferConfirm(input: ProjectTransferConfirmInput!): Boolean!
  "Initiate the transfer of project ownership"
  projectTransferInitiate(input: ProjectTransferInitiateInput!): Boolean!
  "Transfer a project to a team"
  projectTransferToTeam(id: String!, input: ProjectTransferToTeamInput!): Boolean!
  "Transfer a project to a user"
  projectTransferToUser(id: String!): Boolean!
  "Updates a project."
  projectUpdate(id: String!, input: ProjectUpdateInput!): Project!
  "Deletes a ProviderAuth."
  providerAuthRemove(id: String!): Boolean!
  "Generates a new set of recovery codes for the authenticated user."
  recoveryCodeGenerate: RecoveryCodes!
  "Validates a recovery code."
  recoveryCodeValidate(input: RecoveryCodeValidateInput!): Boolean!
  "Updates the ReferralInfo for the authenticated user."
  referralInfoUpdate(input: ReferralInfoUpdateInput!): ReferralInfo!
  "Send a community thread notification email"
  sendCommunityThreadNotificationEmail(input: SendCommunityThreadNotificationEmailInput!): Boolean!
  "Connect a service to a source"
  serviceConnect(id: String!, input: ServiceConnectInput!): Service!
  "Creates a new service."
  serviceCreate(input: ServiceCreateInput!): Service!
  "Deletes a service."
  serviceDelete(
    "[Experimental] Environment ID. If the environment is a forked environment, the service will only be deleted in the specified environment, otherwise it will deleted in all environments that are not forks of other environments"
    environmentId: String,id: String!  ): Boolean!
  "Disconnect a service from a repo"
  serviceDisconnect(id: String!): Service!
  "Creates a new service domain."
  serviceDomainCreate(input: ServiceDomainCreateInput!): ServiceDomain!
  "Deletes a service domain."
  serviceDomainDelete(id: String!): Boolean!
  "Updates a service domain."
  serviceDomainUpdate(input: ServiceDomainUpdateInput!): Boolean!
  "Add a feature flag for a service"
  serviceFeatureFlagAdd(input: ServiceFeatureFlagToggleInput!): Boolean!
  "Remove a feature flag for a service"
  serviceFeatureFlagRemove(input: ServiceFeatureFlagToggleInput!): Boolean!
  "Deploy a service instance"
  serviceInstanceDeploy(environmentId: String!, serviceId: String!): Boolean!
  "Update the resource limits for a service instance"
  serviceInstanceLimitsUpdate(input: ServiceInstanceLimitsUpdateInput!): Boolean!
  "Redeploy a service instance"
  serviceInstanceRedeploy(environmentId: String!, serviceId: String!): Boolean!
  "Update a service instance"
  serviceInstanceUpdate(
    "[Experimental] Environment ID. If the environment is a fork, the service will only be updated in it. Otherwise it will updated in all environments that are not forks of other environments"
    environmentId: String,input: ServiceInstanceUpdateInput!, serviceId: String!  ): Boolean!
  "Remove the upstream URL from all service instances for this service"
  serviceRemoveUpstreamUrl(id: String!): Service!
  "Updates a service."
  serviceUpdate(id: String!, input: ServiceUpdateInput!): Service!
  "Deletes a session."
  sessionDelete(id: String!): Boolean!
  "Configure a shared variable."
  sharedVariableConfigure(input: SharedVariableConfigureInput!): Variable!
  "Creates a new TCP proxy for a service instance."
  tcpProxyCreate(input: TCPProxyCreateInput!): TCPProxy!
  "Deletes a TCP proxy by id"
  tcpProxyDelete(id: String!): Boolean!
  "Bulk transfer projects from user to team"
  teamBulkProjectTransfer(input: TeamBulkProjectTransferInput!): Boolean!
  "Create a team"
  teamCreate(input: TeamCreateInput!): Team!
  "Create a team and subscribe to the Pro plan"
  teamCreateAndSubscribe(input: TeamCreateAndSubscribeInput!): TeamCreateAndSubscribeResponse!
  "Delete a team and all data associated with it"
  teamDelete(id: String!): Boolean!
  "Get an invite code for a team and role"
  teamInviteCodeCreate(id: String!, input: TeamInviteCodeCreateInput!): String!
  "Use an invite code to join a team"
  teamInviteCodeUse(code: String!): Team!
  "Leave a team"
  teamLeave(id: String!): Boolean!
  "Changes a user team permissions."
  teamPermissionChange(input: TeamPermissionChangeInput!): Boolean!
  "Update a team by id"
  teamUpdate(id: String!, input: TeamUpdateInput!): Team!
  "Invite a user by email to a team"
  teamUserInvite(id: String!, input: TeamUserInviteInput!): Boolean!
  "Remove a user from a team"
  teamUserRemove(id: String!, input: TeamUserRemoveInput!): Boolean!
  "Logs panics from CLI to Datadog"
  telemetrySend(input: TelemetrySendInput!): Boolean!
  "Duplicates an existing template"
  templateClone(input: TemplateCloneInput!): Template!
  "Creates a template."
  templateCreate(input: TemplateCreateInput!): Template!
  "Deletes a template."
  templateDelete(id: String!, input: TemplateDeleteInput!): Boolean!
  "Deploys a template."
  templateDeploy(input: TemplateDeployInput!): TemplateDeployPayload! @deprecated(reason: "Deprecated in favor of templateDeployV2")
  "Generate a template for a project"
  templateGenerate(input: TemplateGenerateInput!): Template!
  "Nullify the community thread slug for a template, if one is found with the provided slug"
  templateMaybeUnsetCommunityThreadSlug(communityThreadSlug: String!): Boolean!
  "Publishes a template."
  templatePublish(id: String!, input: TemplatePublishInput!): Template!
  "Ejects a service from the template and creates a new repo in the provided org."
  templateServiceSourceEject(input: TemplateServiceSourceEjectInput!): Boolean!
  "Unpublishes a template."
  templateUnpublish(id: String!): Boolean!
  "Updates a template."
  templateUpdate(id: String!, input: TemplateUpdateInput!): Template!
  "Setup 2FA authorization for authenticated user."
  twoFactorInfoCreate(input: TwoFactorInfoCreateInput!): RecoveryCodes!
  "Deletes the TwoFactorInfo for the authenticated user."
  twoFactorInfoDelete: Boolean!
  "Generates the 2FA app secret for the authenticated user."
  twoFactorInfoSecret: TwoFactorInfoSecret!
  "Validates the token for a 2FA action or for a login request."
  twoFactorInfoValidate(input: TwoFactorInfoValidateInput!): Boolean!
  "Generate a Slack channel for a team"
  upsertSlackChannelForTeam(teamId: String!): Boolean!
  "Remove the usage limit for a customer"
  usageLimitRemove(input: UsageLimitRemoveInput!): Boolean!
  "Set the usage limit for a customer"
  usageLimitSet(input: UsageLimitSetInput!): Boolean!
  "Unsubscribe from the Beta program."
  userBetaLeave: Boolean!
  "Delete the currently authenticated user"
  userDelete: Boolean!
  "Disconnect your Railway account from Discord."
  userDiscordDisconnect: Boolean!
  "Remove a flag on the user."
  userFlagsRemove(input: UserFlagsRemoveInput!): Boolean!
  "Set flags on the authenticated user."
  userFlagsSet(input: UserFlagsSetInput!): Boolean!
  "Updates the profile for the authenticated user"
  userProfileUpdate(input: UserProfileUpdateInput!): Boolean!
  "Disconnect your Railway account from Slack."
  userSlackDisconnect: Boolean!
  "Update date of TermsAgreedOn"
  userTermsUpdate: User
  "Update currently logged in user"
  userUpdate(input: UserUpdateInput!): User
  "Upserts a collection of variables."
  variableCollectionUpsert(input: VariableCollectionUpsertInput!): Boolean!
  "Deletes a variable."
  variableDelete(input: VariableDeleteInput!): Boolean!
  "Upserts a variable."
  variableUpsert(input: VariableUpsertInput!): Boolean!
  "Create a persistent volume in a project"
  volumeCreate(input: VolumeCreateInput!): Volume!
  "Delete a persistent volume in a project"
  volumeDelete(volumeId: String!): Boolean!
  "Update a volume instance. If no environmentId is provided, all volume instances for the volume will be updated."
  volumeInstanceUpdate(
    "The environment of the volume instance to update. If null, all instances for the volume will be updated"
    environmentId: String,input: VolumeInstanceUpdateInput!, 
    "The id of the volume to update"
    volumeId: String!
  ): Boolean!
  "Update a persistent volume in a project"
  volumeUpdate(input: VolumeUpdateInput!, volumeId: String!): Volume!
  "Create a webhook on a project"
  webhookCreate(input: WebhookCreateInput!): ProjectWebhook!
  "Delete a webhook from a project"
  webhookDelete(id: String!): Boolean!
  "Update a webhook on a project"
  webhookUpdate(id: String!, input: WebhookUpdateInput!): ProjectWebhook!
}
type ObservabilityDashboard implements Node {
  id: ID!
  items: [ObservabilityDashboardItemInstance!]!
}
type ObservabilityDashboardItem implements Node {
  config: ObservabilityDashboardItemConfig!
  description: String
  id: ID!
  name: String!
  type: ObservabilityDashboardItemType!
}
type ObservabilityDashboardItemConfig {
  logsFilter: String
  measurements: [MetricMeasurement!]
  projectUsageProperties: [ProjectUsageProperty!]
  resourceIds: [String!]
}
type ObservabilityDashboardItemInstance implements Node {
  dashboardItem: ObservabilityDashboardItem!
  displayConfig: DisplayConfig!
  id: ID!
}
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}
type PaymentMethod {
  card: PaymentMethodCard
  id: String!
}
type PaymentMethodCard {
  brand: String!
  country: String
  last4: String!
}
type PlanLimitOverride implements Node {
  config: SubscriptionPlanLimit!
  id: ID!
}
type PlatformStatus {
  incident: Incident
  isStable: Boolean!
  maintenance: Maintenance
}
type Plugin implements Node {
  containers(after: String, before: String, first: Int, last: Int): PluginContainersConnection!
  createdAt: DateTime!
  deletedAt: DateTime
  deprecatedAt: DateTime
  friendlyName: String!
  id: ID!
  logsEnabled: Boolean!
  migrationDatabaseServiceId: String
  name: PluginType!
  project: Project!
  status: PluginStatus!
  variables(after: String, before: String, first: Int, last: Int): PluginVariablesConnection!
}
type PluginContainersConnection {
  edges: [PluginContainersConnectionEdge!]!
  pageInfo: PageInfo!
}
type PluginContainersConnectionEdge {
  cursor: String!
  node: Container!
}
type PluginVariablesConnection {
  edges: [PluginVariablesConnectionEdge!]!
  pageInfo: PageInfo!
}
type PluginVariablesConnectionEdge {
  cursor: String!
  node: Variable!
}
type Preferences implements Node {
  buildFailedEmail: Boolean!
  changelogEmail: Boolean!
  communityEmail: Boolean!
  deployCrashedEmail: Boolean!
  ephemeralEnvironmentEmail: Boolean!
  id: ID!
  marketingEmail: Boolean!
  subprocessorUpdatesEmail: Boolean!
  usageEmail: Boolean!
}
type PrivateNetwork {
  createdAt: DateTime
  deletedAt: DateTime
  dnsName: String!
  environmentId: String!
  name: String!
  networkId: BigInt!
  projectId: String!
  publicId: String!
  tags: [String!]!
}
type PrivateNetworkEndpoint {
  createdAt: DateTime
  deletedAt: DateTime
  dnsName: String!
  privateIps: [String!]!
  publicId: String!
  serviceInstanceId: String!
  tags: [String!]!
}
type Project implements Node {
  baseEnvironment: Environment
  baseEnvironmentId: String
  botPrEnvironments: Boolean!
  createdAt: DateTime!
  deletedAt: DateTime
  deploymentTriggers(after: String, before: String, first: Int, last: Int): ProjectDeploymentTriggersConnection!
  deployments(after: String, before: String, first: Int, last: Int): ProjectDeploymentsConnection!
  description: String
  environments(after: String, before: String, first: Int, last: Int): ProjectEnvironmentsConnection!
  expiredAt: DateTime
  groups(after: String, before: String, first: Int, last: Int): ProjectGroupsConnection!
  id: ID!
  isPublic: Boolean!
  isTempProject: Boolean!
  members: [ProjectMember!]!
  name: String!
  plugins(after: String, before: String, first: Int, last: Int): ProjectPluginsConnection!
  prDeploys: Boolean!
  projectPermissions(after: String, before: String, first: Int, last: Int): ProjectProjectPermissionsConnection!
  services(after: String, before: String, first: Int, last: Int): ProjectServicesConnection!
  subscriptionPlanLimit: SubscriptionPlanLimit!
  subscriptionType: SubscriptionPlanType!
  team: Team
  teamId: String
  updatedAt: DateTime!
  volumes(after: String, before: String, first: Int, last: Int): ProjectVolumesConnection!
  webhooks(after: String, before: String, first: Int, last: Int): ProjectWebhooksConnection!
}
type ProjectDeploymentTriggersConnection {
  edges: [ProjectDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}
type ProjectDeploymentsConnection {
  edges: [ProjectDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}
type ProjectEnvironmentsConnection {
  edges: [ProjectEnvironmentsConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectEnvironmentsConnectionEdge {
  cursor: String!
  node: Environment!
}
type ProjectGroupsConnection {
  edges: [ProjectGroupsConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectGroupsConnectionEdge {
  cursor: String!
}
type ProjectInvitation {
  email: String!
  expiresAt: DateTime!
  id: ID!
  inviter: ProjectInvitationInviter
  isExpired: Boolean!
  project: PublicProjectInformation!
}
type ProjectInvitationInviter {
  email: String!
  name: String
}
type ProjectMember {
  avatar: String
  email: String!
  id: String!
  name: String
  role: ProjectRole!
}
type ProjectPermission implements Node {
  id: ID!
  projectId: String!
  role: ProjectRole!
  userId: String!
}
type ProjectPluginsConnection {
  edges: [ProjectPluginsConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectPluginsConnectionEdge {
  cursor: String!
  node: Plugin!
}
type ProjectProjectPermissionsConnection {
  edges: [ProjectProjectPermissionsConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectProjectPermissionsConnectionEdge {
  cursor: String!
  node: ProjectPermission!
}
type ProjectResourceAccess {
  customDomain: AccessRule!
  databaseDeployment: AccessRule!
  deployment: AccessRule!
  environment: AccessRule!
  plugin: AccessRule!
}
type ProjectServicesConnection {
  edges: [ProjectServicesConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectServicesConnectionEdge {
  cursor: String!
  node: Service!
}
type ProjectToken implements Node {
  createdAt: DateTime!
  displayToken: String!
  environment: Environment!
  environmentId: String!
  id: ID!
  name: String!
  project: Project!
  projectId: String!
}
type ProjectVolumesConnection {
  edges: [ProjectVolumesConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectVolumesConnectionEdge {
  cursor: String!
  node: Volume!
}
type ProjectWebhook implements Node {
  id: ID!
  lastStatus: Int
  projectId: String!
  url: String!
}
type ProjectWebhooksConnection {
  edges: [ProjectWebhooksConnectionEdge!]!
  pageInfo: PageInfo!
}
type ProjectWebhooksConnectionEdge {
  cursor: String!
  node: ProjectWebhook!
}
type ProviderAuth implements Node {
  email: String!
  id: ID!
  metadata: JSON!
  provider: String!
  userId: String!
}
type PublicProjectInformation {
  id: ID!
  name: String!
}
type PublicStats {
  totalDeploymentsLastMonth: Int!
  totalLogsLastMonth: BigInt!
  totalProjects: Int!
  totalRequestsLastMonth: BigInt!
  totalServices: Int!
  totalUsers: Int!
}
type Query {
  "Get all volume instances for a given volume"
  adminVolumeInstancesForVolume(volumeId: String!): [VolumeInstance!]!
  "Gets all API tokens for the authenticated user."
  apiTokens(after: String, before: String, first: Int, last: Int): QueryApiTokensConnection!
  "Fetch logs for a build"
  buildLogs(deploymentId: String!, endDate: DateTime, 
    "Filter logs by a string. Providing an empty value will match all logs."
    filter: String,
    "Limit the number of logs returned (defaults 100, max 5000)"
    limit: Int,startDate: DateTime  ): [Log!]!
  "Gets the image URL for a Notion image block"
  changelogBlockImage(id: String!): String!
  "Get the total count and sum of transfers to date."
  creditTransferMetrics: CreditTransferMetrics!
  "Fetch details for a custom domain"
  customDomain(id: String!, projectId: String!): CustomDomain!
  "Checks if a custom domain is available."
  customDomainAvailable(domain: String!): DomainAvailable!
  "Find a single deployment"
  deployment(id: String!): Deployment!
  "Get the deployment events for a deployment"
  deploymentEvents(after: String, before: String, first: Int, id: String!, last: Int): QueryDeploymentEventsConnection!
  "Fetch logs for a deployment"
  deploymentLogs(deploymentId: String!, endDate: DateTime, 
    "Filter logs by a string. Providing an empty value will match all logs."
    filter: String,
    "Limit the number of logs returned (defaults 100, max 5000)"
    limit: Int,startDate: DateTime  ): [Log!]!
  "Find a single DeploymentSnapshot"
  deploymentSnapshot(deploymentId: String!): DeploymentSnapshot
  "All deployment triggers."
  deploymentTriggers(after: String, before: String, environmentId: String!, first: Int, last: Int, projectId: String!, serviceId: String!): QueryDeploymentTriggersConnection!
  "Get all deployments"
  deployments(after: String, before: String, first: Int, input: DeploymentListInput!, last: Int): QueryDeploymentsConnection!
  "Domain with status"
  domainStatus(id: String!, projectId: String!): DomainWithStatus! @deprecated(reason: "Use the `status` field within the `domain` query instead")
  "All domains for a service instance"
  domains(environmentId: String!, projectId: String!, serviceId: String!): AllDomains!
  "All egress gateways assigned to a service instance"
  egressGateways(environmentId: String!, serviceId: String!): [EgressGateway!]!
  "Find a single environment"
  environment(id: String!): Environment!
  "Get the patches for an environment"
  environmentPatches(after: String, before: String, environmentId: String!, first: Int, last: Int): QueryEnvironmentPatchesConnection!
  "Gets all environments for a project."
  environments(after: String, before: String, first: Int, isEphemeral: Boolean, last: Int, projectId: String!): QueryEnvironmentsConnection!
  "Get the estimated total cost of the project at the end of the current billing cycle"
  estimatedUsage(
    "Whether to include deleted projects in estimations."
    includeDeleted: Boolean,measurements: [MetricMeasurement!]!, projectId: String, teamId: String, userId: String  ): [EstimatedUsage!]!
  "Gets the events for a project."
  events(after: String, before: String, environmentId: String, filter: EventFilterInput, first: Int, last: Int, projectId: String!): QueryEventsConnection!
  "Checks if user has access to GitHub repository"
  gitHubRepoAccessAvailable(fullRepoName: String!): GitHubAccess!
  "Check if a repo name is available"
  githubIsRepoNameAvailable(fullRepoName: String!): Boolean!
  "Get branches for a GitHub repo that the authenticated user has access to"
  githubRepoBranches(owner: String!, repo: String!): [GitHubBranch!]!
  "Get a list of repos for a user that Railway has access to"
  githubRepos: [GitHubRepo!]!
  "Get a list of scopes the user has installed the installation to"
  githubWritableScopes: [String!]!
  "Get the Herokus apps for the current user"
  herokuApps: [HerokuApp!]!
  "Get an integration auth by provider providerId"
  integrationAuth(provider: String!, providerId: String!): IntegrationAuth!
  "Get all integration auths for a user"
  integrationAuths(after: String, before: String, first: Int, last: Int): QueryIntegrationAuthsConnection!
  "Get all integrations for a project"
  integrations(after: String, before: String, first: Int, last: Int, projectId: String!): QueryIntegrationsConnection!
  "Get an invite code by the code"
  inviteCode(code: String!): InviteCode!
  "Gets the authenticated user."
  me: User!
  "Get metrics for a project, environment, and service"
  metrics(
    "The averaging window when computing CPU usage. By default, it is the same as the `sampleRateSeconds`."
    averagingWindowSeconds: Int,
    "The end of the period to get metrics for. If not provided, the current datetime is used."
    endDate: DateTime,environmentId: String, 
    "What to group the aggregated usage by. By default, it is grouped over the entire project."
    groupBy: [MetricTag!],
    "Whether or not to include deleted projects in the results"
    includeDeleted: Boolean,measurements: [MetricMeasurement!]!, pluginId: String, projectId: String, 
    "The frequency of data points in the response. If the `sampleRateSeconds` is 60, then the response will contain one data point per minute."
    sampleRateSeconds: Int,serviceId: String, 
    "The start of the period to get metrics for."
    startDate: DateTime!,teamId: String, userId: String, volumeId: String  ): [MetricsResult!]!
  ""
  node(id: ID!): Node
  ""
  nodes(ids: [ID!]!): [Node]!
  "Get all observability dashboards for an environment"
  observabilityDashboards(after: String, before: String, environmentId: String!, first: Int, last: Int): QueryObservabilityDashboardsConnection!
  "Get a user's Plain Customer ID given their Discord ID."
  plainCustomerIdForDiscordId(discordId: String!): String!
  "Get a user JWT token for a Discord id"
  plainJWTForDiscordId(discordId: String!): String!
  "Get the current status of the platform"
  platformStatus: PlatformStatus!
  "Get a plugin by ID."
  plugin(id: String!): Plugin!
  "Fetch logs for a plugin"
  pluginLogs(endDate: DateTime, environmentId: String!, 
    "Filter logs by a string. Providing an empty value will match all logs."
    filter: String,
    "Limit the number of logs returned (defaults 100, max 5000)"
    limit: Int,pluginId: String!, startDate: DateTime  ): [Log!]!
  "Get the email preferences for a user"
  preferences(token: String): Preferences!
  "Get a private network endpoint for a service instance."
  privateNetworkEndpoint(environmentId: String!, privateNetworkId: String!, serviceId: String!): PrivateNetworkEndpoint
  "Check if an endpoint name is available."
  privateNetworkEndpointNameAvailable(environmentId: String!, prefix: String!, privateNetworkId: String!): Boolean!
  "List private networks for an environment."
  privateNetworks(environmentId: String!): [PrivateNetwork!]!
  "Get a project by ID"
  project(id: String!): Project!
  "Get a project invitation by code"
  projectInvitation(code: String!): PublicProjectInvitation!
  "Get invitations for a project"
  projectInvitations(id: String!): [ProjectInvitation!]!
  "Get an invite code for a project for a specifc role"
  projectInviteCode(projectId: String!, role: ProjectRole!): InviteCode!
  "Gets users who belong to a project along with their role"
  projectMembers(projectId: String!): [ProjectMember!]!
  "Get resource access rules for project-specific actions"
  projectResourceAccess(projectId: String!): ProjectResourceAccess!
  "Get a single project token by the value in the header"
  projectToken: ProjectToken!
  "Get all project tokens for a project"
  projectTokens(after: String, before: String, first: Int, last: Int, projectId: String!): QueryProjectTokensConnection!
  "Gets all projects for a user or a team."
  projects(after: String, before: String, first: Int, includeDeleted: Boolean, last: Int, teamId: String, userId: String): QueryProjectsConnection!
  "Get public Railway stats."
  publicStats: PublicStats!
  "Gets the ReferralInfo for the authenticated user."
  referralInfo: ReferralInfo!
  "List available regions"
  regions: [Region!]!
  "Get resource access for the current user or team"
  resourceAccess(explicitResourceOwner: ExplicitOwnerInput): ResourceAccess!
  "Get a service by ID"
  service(id: String!): Service!
  "Checks if a service domain is available"
  serviceDomainAvailable(domain: String!): DomainAvailable!
  "Get a service instance belonging to a service and environment"
  serviceInstance(environmentId: String!, serviceId: String!): ServiceInstance!
  "Check if the upstream repo for a service has an update available"
  serviceInstanceIsUpdatable(environmentId: String!, serviceId: String!): Boolean!
  "Get the resource limits for a service instance"
  serviceInstanceLimitOverride(environmentId: String!, projectId: String!, serviceId: String!): ServiceInstanceLimit!
  "Get the resource limits for a service instance"
  serviceInstanceLimits(environmentId: String!, projectId: String!, serviceId: String!): ServiceInstanceLimit!
  "Gets all sessions for authenticated user."
  sessions(after: String, before: String, first: Int, last: Int): QuerySessionsConnection!
  "All TCP proxies for a service instance"
  tcpProxies(environmentId: String!, serviceId: String!): [TCPProxy!]!
  "Find a team by ID"
  team(id: String!): Team!
  "Find a team by invite code"
  teamByCode(code: String!): Team!
  "Fetch Discord info associated with Direct Support-eligible team members, given a Discord UID"
  teamDirectSupportDiscordInfoForDiscordId(discordId: String!): TeamDirectSupportDiscordInfo
  "Get all templates for a team."
  teamTemplates(after: String, before: String, first: Int, last: Int, teamId: String!): QueryTeamTemplatesConnection!
  "Get a template by code or GitHub owner and repo."
  template(code: String, owner: String, repo: String): Template!
  "Get the top 25 users with the most template kickback earnings."
  templateKickbacksLeaderboard: [TemplateKickbacksLeaderboard!]!
  "Get the source template for a project."
  templateSourceForProject(projectId: String!): Template
  "Get the all-time sum of template kickbacks."
  templatekickbacksTotal: Float!
  "Get all published templates."
  templates(after: String, before: String, first: Int, last: Int, 
    "If set to true, only recommended templates will be returned."
    recommended: Boolean
  ): QueryTemplatesConnection!
  "Gets the TwoFactorInfo for the authenticated user."
  twoFactorInfo: TwoFactorInfo!
  "Get the usage for a single project or all projects for a user/team. If no `projectId` or `teamId` is provided, the usage for the current user is returned."
  usage(endDate: DateTime, 
    "What to group the aggregated usage by. By default, it is grouped over the entire project."
    groupBy: [MetricTag!],
    "Whether to include deleted projects in the usage."
    includeDeleted: Boolean,measurements: [MetricMeasurement!]!, projectId: String, startDate: DateTime, teamId: String, userId: String  ): [AggregatedUsage!]!
  "Get the user id corresponding to a Discord id"
  userIdForDiscordId(discordId: String!): String!
  "Get the user id corresponding to a Slack id"
  userIdForSlackId(slackId: String!): String
  "Get the total kickback earnings for a user."
  userKickbackEarnings(userId: String!): UserKickbackEarnings! @deprecated(reason: "This field is deprecated and will be removed in future versions.")
  "Get the public profile for a user"
  userProfile(username: String!): UserProfileResponse!
  "Get all templates for the current user."
  userTemplates(after: String, before: String, first: Int, last: Int): QueryUserTemplatesConnection!
  "All variables by pluginId or serviceId. If neither are provided, all shared variables are returned."
  variables(environmentId: String!, 
    "Provide a pluginId to get all variables for a specific plugin."
    pluginId: String,projectId: String!, 
    "Provide a serviceId to get all variables for a specific service."
    serviceId: String,unrendered: Boolean  ): ServiceVariables!
  "All rendered variables that are required for a service deployment."
  variablesForServiceDeployment(environmentId: String!, projectId: String!, serviceId: String!): ServiceVariables!
  "Get information about the user's Vercel accounts"
  vercelInfo: VercelInfo!
  "Get a single volume instance by id"
  volumeInstance(id: String!): VolumeInstance!
  "Get all webhooks for a project"
  webhooks(after: String, before: String, first: Int, last: Int, projectId: String!): QueryWebhooksConnection!
  "Gets the status of a workflow"
  workflowStatus(workflowId: String!): WorkflowResult!
}
type QueryApiTokensConnection {
  edges: [QueryApiTokensConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryApiTokensConnectionEdge {
  cursor: String!
  node: ApiToken!
}
type QueryDeploymentEventsConnection {
  edges: [QueryDeploymentEventsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryDeploymentEventsConnectionEdge {
  cursor: String!
  node: DeploymentEvent!
}
type QueryDeploymentTriggersConnection {
  edges: [QueryDeploymentTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryDeploymentTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}
type QueryDeploymentsConnection {
  edges: [QueryDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}
type QueryEnvironmentPatchesConnection {
  edges: [QueryEnvironmentPatchesConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryEnvironmentPatchesConnectionEdge {
  cursor: String!
}
type QueryEnvironmentsConnection {
  edges: [QueryEnvironmentsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryEnvironmentsConnectionEdge {
  cursor: String!
  node: Environment!
}
type QueryEventsConnection {
  edges: [QueryEventsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryEventsConnectionEdge {
  cursor: String!
  node: Event!
}
type QueryIntegrationAuthsConnection {
  edges: [QueryIntegrationAuthsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryIntegrationAuthsConnectionEdge {
  cursor: String!
  node: IntegrationAuth!
}
type QueryIntegrationsConnection {
  edges: [QueryIntegrationsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryIntegrationsConnectionEdge {
  cursor: String!
  node: Integration!
}
type QueryObservabilityDashboardsConnection {
  edges: [QueryObservabilityDashboardsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryObservabilityDashboardsConnectionEdge {
  cursor: String!
  node: ObservabilityDashboard!
}
type QueryProjectTokensConnection {
  edges: [QueryProjectTokensConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryProjectTokensConnectionEdge {
  cursor: String!
  node: ProjectToken!
}
type QueryProjectsConnection {
  edges: [QueryProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryProjectsConnectionEdge {
  cursor: String!
  node: Project!
}
type QuerySessionsConnection {
  edges: [QuerySessionsConnectionEdge!]!
  pageInfo: PageInfo!
}
type QuerySessionsConnectionEdge {
  cursor: String!
  node: Session!
}
type QueryTeamTemplatesConnection {
  edges: [QueryTeamTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryTeamTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}
type QueryTemplatesConnection {
  edges: [QueryTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}
type QueryUserTemplatesConnection {
  edges: [QueryUserTemplatesConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryUserTemplatesConnectionEdge {
  cursor: String!
  node: Template!
}
type QueryWebhooksConnection {
  edges: [QueryWebhooksConnectionEdge!]!
  pageInfo: PageInfo!
}
type QueryWebhooksConnectionEdge {
  cursor: String!
  node: ProjectWebhook!
}
type RecoveryCodes {
  recoveryCodes: [String!]!
}
type ReferralInfo implements Node {
  code: String!
  id: ID!
  referralStats: ReferralStats!
  status: String!
}
type ReferralStats {
  credited: Int!
  pending: Int!
}
type ReferralUser {
  code: String!
  id: String!
  status: ReferralStatus!
}
type RefundRequest implements Node {
  amount: Int!
  decision: RefundRequestDecisionEnum
  id: ID!
  invoiceId: String!
  plainThreadId: String
  reason: String!
  teamId: String
  userId: String!
}
type Region {
  adminOnly: Boolean
  country: String
  location: String
  name: String!
  region: String
}
type ResourceAccess {
  project: AccessRule!
}
type Service implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deployments(after: String, before: String, first: Int, last: Int): ServiceDeploymentsConnection!
  featureFlags: [ActiveServiceFeatureFlag!]!
  icon: String
  id: ID!
  name: String!
  project: Project!
  projectId: String!
  repoTriggers(after: String, before: String, first: Int, last: Int): ServiceRepoTriggersConnection!
  serviceInstances(after: String, before: String, first: Int, last: Int): ServiceServiceInstancesConnection!
  templateServiceId: String
  templateThreadSlug: String
  updatedAt: DateTime!
}
type ServiceDeploymentsConnection {
  edges: [ServiceDeploymentsConnectionEdge!]!
  pageInfo: PageInfo!
}
type ServiceDeploymentsConnectionEdge {
  cursor: String!
  node: Deployment!
}
type ServiceDomain implements Domain {
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  suffix: String
  targetPort: Int
  updatedAt: DateTime
}
type ServiceInstance implements Node {
  buildCommand: String
  builder: Builder!
  createdAt: DateTime!
  cronSchedule: String
  deletedAt: DateTime
  domains: AllDomains!
  environmentId: String!
  healthcheckPath: String
  healthcheckTimeout: Int
  id: ID!
  isUpdatable: Boolean!
  latestDeployment: Deployment
  nextCronRunAt: DateTime
  nixpacksPlan: JSON
  numReplicas: Int
  railwayConfigFile: String
  region: String
  restartPolicyMaxRetries: Int!
  restartPolicyType: RestartPolicyType!
  rootDirectory: String
  serviceId: String!
  sleepApplication: Boolean
  source: ServiceSource
  startCommand: String
  updatedAt: DateTime!
  upstreamUrl: String
  watchPatterns: [String!]!
}
type ServiceRepoTriggersConnection {
  edges: [ServiceRepoTriggersConnectionEdge!]!
  pageInfo: PageInfo!
}
type ServiceRepoTriggersConnectionEdge {
  cursor: String!
  node: DeploymentTrigger!
}
type ServiceServiceInstancesConnection {
  edges: [ServiceServiceInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}
type ServiceServiceInstancesConnectionEdge {
  cursor: String!
  node: ServiceInstance!
}
type ServiceSource {
  image: String
  repo: String
}
type Session implements Node {
  createdAt: DateTime!
  expiredAt: DateTime!
  id: ID!
  isCurrent: Boolean!
  name: String!
  type: SessionType!
  updatedAt: DateTime!
}
type SimilarTemplate {
  code: String!
  createdAt: DateTime!
  creator: TemplateCreator
  deploys: Int!
  description: String
  health: Float
  image: String
  name: String!
  teamId: String
  userId: String
}
type Subscription {
  "Stream logs for a build"
  buildLogs(deploymentId: String!, 
    "Filter logs by a string. Providing an empty value will match all logs."
    filter: String,
    "Limit the number of logs returned (defaults 100, max 5000)"
    limit: Int
  ): [Log!]!
  "Subscribe to updates for a specific deployment"
  deployment(id: String!): Deployment!
  "Subscribe to deployment events for a specific deployment"
  deploymentEvents(id: String!): DeploymentEvent!
  "Stream logs for a deployment"
  deploymentLogs(deploymentId: String!, 
    "Filter logs by a string. Providing an empty value will match all logs."
    filter: String,
    "Limit the number of logs returned (defaults 100, max 5000)"
    limit: Int
  ): [Log!]!
  "Stream logs for a plugin"
  pluginLogs(environmentId: String!, 
    "Filter logs by a string. Providing an empty value will match all logs."
    filter: String,
    "Limit the number of logs returned (defaults 100, max 5000)"
    limit: Int,pluginId: String!  ): [Log!]!
}
type SubscriptionDiscount {
  couponId: String!
}
type SubscriptionItem {
  itemId: String!
  priceId: String!
  productId: String!
  quantity: BigInt
}
type TCPProxy {
  applicationPort: Int!
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  environmentId: String!
  id: ID!
  proxyPort: Int!
  serviceId: String!
  updatedAt: DateTime
}
type Team implements Node {
  adoptionHistory: [AdoptionInfo!]!
  adoptionLevel: Float!
  avatar: String
  banReason: String
  createdAt: DateTime!
  customer: Customer!
  discordRole: String
  id: ID!
  isEligibleForDirectSupport: Boolean!
  members: [TeamMember!]!
  name: String!
  projects(after: String, before: String, first: Int, last: Int): TeamProjectsConnection!
  slackChannelId: String
  teamPermissions: [TeamPermission!]!
  updatedAt: DateTime!
}
type TeamCreateAndSubscribeResponse {
  customerId: String!
  paymentIntent: JSON
  teamId: String!
}
type TeamDirectSupportDiscordInfo {
  memberDiscordIds: [String!]!
  teamId: String!
  teamName: String!
}
type TeamMember {
  avatar: String
  email: String!
  "Only retrieved if requested by an admin"
  featureFlags: [ActiveFeatureFlag!]
  id: String!
  name: String
  role: TeamRole!
}
type TeamPermission implements Node {
  createdAt: DateTime!
  id: ID!
  role: TeamRole!
  teamId: String!
  updatedAt: DateTime!
  userId: String!
}
type TeamProjectsConnection {
  edges: [TeamProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}
type TeamProjectsConnectionEdge {
  cursor: String!
  node: Project!
}
type Template implements Node {
  activeProjects: Int!
  canvasConfig: CanvasConfig
  code: String!
  communityThreadSlug: String
  config: TemplateConfig!
  createdAt: DateTime!
  creator: TemplateCreator
  demoProjectId: String
  health: Float
  id: ID!
  isApproved: Boolean!
  isV2Template: Boolean!
  metadata: TemplateMetadata!
  projects: Int!
  serializedConfig: SerializedTemplateConfig
  services(after: String, before: String, first: Int, last: Int): TemplateServicesConnection!
  similarTemplates: [SimilarTemplate!]!
  status: TemplateStatus!
  teamId: String
  totalPayout: Float!
  userId: String
}
type TemplateCreator {
  avatar: String
  hasPublicProfile: Boolean!
  name: String
  username: String
}
type TemplateDeployPayload {
  projectId: String!
  workflowId: String
}
type TemplateKickbacksLeaderboard {
  total_amount: Float!
  userId: String!
}
type TemplateService implements Node {
  config: TemplateServiceConfig!
  createdAt: DateTime!
  id: ID!
  templateId: String!
  updatedAt: DateTime!
}
type TemplateServicesConnection {
  edges: [TemplateServicesConnectionEdge!]!
  pageInfo: PageInfo!
}
type TemplateServicesConnectionEdge {
  cursor: String!
  node: TemplateService!
}
type TwoFactorInfo {
  hasRecoveryCodes: Boolean!
  isVerified: Boolean!
}
type TwoFactorInfoSecret {
  secret: String!
  uri: String!
}
type UsageAnomaly implements Node {
  actedOn: DateTime
  action: UsageAnomalyAction
  actorId: String
  flaggedAt: DateTime!
  flaggedFor: UsageAnomalyFlagReason!
  id: ID!
}
type UsageLimit implements Node {
  customerId: String!
  hardLimit: Int
  id: ID!
  softLimit: Int!
}
type User implements Node {
  agreedFairUse: Boolean!
  avatar: String
  banReason: String
  cost: UserCost!
  createdAt: DateTime!
  customer: Customer!
  email: String!
  featureFlags: [ActiveFeatureFlag!]!
  flags: [UserFlag!]!
  has2FA: Boolean!
  id: ID!
  isAdmin: Boolean!
  isConductor: Boolean!
  isDevPlan: Boolean!
  isEligibleForFreeHobbyPlan: Boolean!
  isOnHobbyPlan: Boolean!
  isVerified: Boolean!
  lastLogin: DateTime!
  name: String
  profile: UserProfile
  projects(after: String, before: String, first: Int, last: Int): UserProjectsConnection!
  providerAuths(after: String, before: String, first: Int, last: Int): UserProviderAuthsConnection!
  referredUsers: [ReferralUser!]!
  registrationStatus: RegistrationStatus!
  riskLevel: Float
  teams(after: String, before: String, first: Int, last: Int): UserTeamsConnection!
  termsAgreedOn: DateTime
  username: String
}
type UserCost {
  current: Float!
  estimated: Float!
}
type UserKickbackEarnings {
  total_amount: Float!
}
type UserProfile {
  bio: String
  isPublic: Boolean!
  website: String
}
type UserProfileResponse {
  avatar: String
  createdAt: DateTime!
  customerId: String
  id: String!
  isTrialing: Boolean
  name: String
  profile: UserProfile!
  "Gets all public projects for a user."
  publicProjects(after: String, before: String, first: Int, last: Int): UserProfileResponsePublicProjectsConnection!
  publishedTemplates: [SimilarTemplate!]!
  state: String
  totalDeploys: Int!
  username: String
}
type UserProfileResponsePublicProjectsConnection {
  edges: [UserProfileResponsePublicProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}
type UserProfileResponsePublicProjectsConnectionEdge {
  cursor: String!
  node: Project!
}
type UserProjectsConnection {
  edges: [UserProjectsConnectionEdge!]!
  pageInfo: PageInfo!
}
type UserProjectsConnectionEdge {
  cursor: String!
  node: Project!
}
type UserProviderAuthsConnection {
  edges: [UserProviderAuthsConnectionEdge!]!
  pageInfo: PageInfo!
}
type UserProviderAuthsConnectionEdge {
  cursor: String!
  node: ProviderAuth!
}
type UserTeamsConnection {
  edges: [UserTeamsConnectionEdge!]!
  pageInfo: PageInfo!
}
type UserTeamsConnectionEdge {
  cursor: String!
  node: Team!
}
type Variable implements Node {
  createdAt: DateTime!
  environment: Environment!
  environmentId: String
  id: ID!
  name: String!
  plugin: Plugin!
  pluginId: String
  references: [String!]!
  service: Service!
  serviceId: String
  updatedAt: DateTime!
}
type VercelAccount {
  id: String!
  integrationAuthId: String!
  isUser: Boolean!
  name: String
  projects: [VercelProject!]!
  slug: String
}
type VercelInfo {
  accounts: [VercelAccount!]!
}
type VercelProject {
  accountId: String!
  id: String!
  name: String!
}
type Volume implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  project: Project!
  projectId: String!
  volumeInstances(after: String, before: String, first: Int, last: Int): VolumeVolumeInstancesConnection!
}
type VolumeInstance implements Node {
  createdAt: DateTime!
  currentSizeMB: Float!
  environment: Environment!
  environmentId: String!
  externalId: String
  id: ID!
  mountPath: String!
  region: String
  service: Service!
  serviceId: String
  sizeMB: Int!
  state: VolumeState
  volume: Volume!
  volumeId: String!
}
type VolumeVolumeInstancesConnection {
  edges: [VolumeVolumeInstancesConnectionEdge!]!
  pageInfo: PageInfo!
}
type VolumeVolumeInstancesConnectionEdge {
  cursor: String!
  node: VolumeInstance!
}
type Withdrawal implements Node {
  amount: Float!
  createdAt: DateTime!
  customerId: String!
  id: ID!
  status: WithdrawalStatusType!
  updatedAt: DateTime!
  withdrawalAccountId: String!
}
type WithdrawalAccount implements Node {
  customerId: String!
  id: ID!
  platform: WithdrawalPlatformTypes!
  platformDetails: String!
}
type WorkflowResult {
  error: String
  status: WorkflowStatus!
}
interface Domain {
  createdAt: DateTime
  deletedAt: DateTime
  domain: String!
  environmentId: String!
  id: ID!
  projectId: String
  serviceId: String!
  targetPort: Int
  updatedAt: DateTime
}
interface Node {
  id: ID!
}
union PublicProjectInvitation = InviteCode | ProjectInvitation
enum ActiveFeatureFlag {
  PRIORITY_BOARDING
}
enum ActiveServiceFeatureFlag {
  PLACEHOLDER
}
enum Builder {
  HEROKU
  NIXPACKS
  PAKETO
}
enum CDNProvider {
  DETECTED_CDN_PROVIDER_CLOUDFLARE
  DETECTED_CDN_PROVIDER_UNSPECIFIED
  UNRECOGNIZED
}
enum CertificateStatus {
  CERTIFICATE_STATUS_TYPE_ISSUE_FAILED
  CERTIFICATE_STATUS_TYPE_ISSUING
  CERTIFICATE_STATUS_TYPE_UNSPECIFIED
  CERTIFICATE_STATUS_TYPE_VALID
  UNRECOGNIZED
}
enum CnameCheckStatus {
  ERROR
  INFO
  INVALID
  VALID
  WAITING
}
enum CreditType {
  APPLIED
  CREDIT
  DEBIT
  STRIPE
  TRANSFER
  WAIVED
}
enum DNSRecordPurpose {
  DNS_RECORD_PURPOSE_ACME_DNS01_CHALLENGE
  DNS_RECORD_PURPOSE_TRAFFIC_ROUTE
  DNS_RECORD_PURPOSE_UNSPECIFIED
  UNRECOGNIZED
}
enum DNSRecordStatus {
  DNS_RECORD_STATUS_PROPAGATED
  DNS_RECORD_STATUS_REQUIRES_UPDATE
  DNS_RECORD_STATUS_UNSPECIFIED
  UNRECOGNIZED
}
enum DNSRecordType {
  DNS_RECORD_TYPE_A
  DNS_RECORD_TYPE_CNAME
  DNS_RECORD_TYPE_NS
  DNS_RECORD_TYPE_UNSPECIFIED
  UNRECOGNIZED
}
enum DeploymentEventStep {
  BUILD_IMAGE
  CREATE_CONTAINER
  DRAIN_INSTANCES
  HEALTHCHECK
  PUBLISH_IMAGE
  SNAPSHOT_CODE
}
enum DeploymentStatus {
  BUILDING
  CRASHED
  DEPLOYING
  FAILED
  INITIALIZING
  QUEUED
  REMOVED
  REMOVING
  SKIPPED
  SLEEPING
  SUCCESS
  WAITING
}
enum IncidentStatus {
  IDENTIFIED
  INVESTIGATING
  MONITORING
  RESOLVED
}
enum KeyType {
  KEY_TYPE_ECDSA
  KEY_TYPE_RSA_2048
  KEY_TYPE_RSA_4096
  KEY_TYPE_UNSPECIFIED
  UNRECOGNIZED
}
enum MaintenanceStatus {
  COMPLETED
  INPROGRESS
  NOTSTARTEDYET
}
"A thing that can be measured on Railway."
enum MetricMeasurement {
  CPU_LIMIT
  CPU_USAGE
  DISK_USAGE_GB
  EPHEMERAL_DISK_USAGE_GB
  MEASUREMENT_UNSPECIFIED
  MEMORY_LIMIT_GB
  MEMORY_USAGE_GB
  NETWORK_RX_GB
  NETWORK_TX_GB
  UNRECOGNIZED
}
"A property that can be used to group metrics."
enum MetricTag {
  DEPLOYMENT_ID
  DEPLOYMENT_INSTANCE_ID
  ENVIRONMENT_ID
  KEY_UNSPECIFIED
  PLUGIN_ID
  PROJECT_ID
  SERVICE_ID
  UNRECOGNIZED
  VOLUME_ID
}
enum ObservabilityDashboardItemType {
  PROJECT_USAGE_ITEM
  SERVICE_LOGS_ITEM
  SERVICE_METRICS_ITEM
  VOLUME_METRICS_ITEM
}
enum PluginStatus {
  DEPRECATED
  LOCKED
  REMOVED
  RUNNING
  STOPPED
}
enum PluginType {
  mongodb
  mysql
  postgresql
  redis
}
enum ProjectRole {
  ADMIN
  MEMBER
  VIEWER
}
enum ProjectUsageProperty {
  CPU_USAGE
  CURRENT_USAGE
  DISK_USAGE
  ESTIMATED_USAGE
  MEMORY_USAGE
  NETWORK_USAGE
}
enum PublicRuntime {
  LEGACY
  UNSPECIFIED
  V2
}
enum ReferralStatus {
  REFEREE_CREDITED
  REFERRER_CREDITED
  REGISTERED
}
"Possible decisions for a RefundRequest"
enum RefundRequestDecisionEnum {
  AUTO_REFUNDED
  AUTO_REJECTED
  MANUALLY_REFUNDED
}
enum RegistrationStatus {
  ONBOARDED
  REGISTERED
  WAITLISTED
}
enum ResourceOwnerType {
  TEAM
  USER
}
enum RestartPolicyType {
  ALWAYS
  NEVER
  ON_FAILURE
}
enum SessionType {
  BROWSER
  CLI
  FORUMS
}
enum SubscriptionPlanType {
  hobby
  pro
  trial
}
enum SubscriptionState {
  ACTIVE
  CANCELLED
  INACTIVE
  PAST_DUE
  UNPAID
}
enum TeamRole {
  ADMIN
  MEMBER
}
enum TemplateStatus {
  HIDDEN
  PUBLISHED
  UNPUBLISHED
}
"Possible actions for a UsageAnomaly."
enum UsageAnomalyAction {
  ALLOWED
  AUTOBANNED
  BANNED
}
"Possible flag reasons for a UsageAnomaly."
enum UsageAnomalyFlagReason {
  HIGH_CPU_USAGE
  HIGH_DISK_USAGE
  HIGH_NETWORK_USAGE
}
enum UserFlag {
  BETA
}
enum VolumeState {
  DELETED
  DELETING
  ERROR
  MIGRATING
  MIGRATION_PENDING
  READY
  UPDATING
}
enum WithdrawalPlatformTypes {
  BMAC
  GITHUB
  PAYPAL
}
enum WithdrawalStatusType {
  CANCELLED
  COMPLETED
  FAILED
  PENDING
}
enum WorkflowStatus {
  Complete
  Error
  NotFound
  Running
}
input ApiTokenCreateInput {
  name: String!
  teamId: String
}
input BaseEnvironmentOverrideInput {
  baseEnvironmentOverrideId: String
}
input CustomDomainCreateInput {
  domain: String!
  environmentId: String!
  projectId: String!
  serviceId: String!
  targetPort: Int
}
input DeploymentListInput {
  environmentId: String
  includeDeleted: Boolean
  projectId: String
  serviceId: String
  status: DeploymentStatusInput
}
input DeploymentStatusInput {
  in: [DeploymentStatus!]
  notIn: [DeploymentStatus!]
}
input DeploymentTriggerCreateInput {
  branch: String!
  checkSuites: Boolean
  environmentId: String!
  projectId: String!
  provider: String!
  repository: String!
  rootDirectory: String
  serviceId: String!
}
input DeploymentTriggerUpdateInput {
  branch: String
  checkSuites: Boolean
  repository: String
  rootDirectory: String
}
input EgressGatewayCreateInput {
  environmentId: String!
  region: String
  serviceId: String!
}
input EgressGatewayServiceTargetInput {
  environmentId: String!
  serviceId: String!
}
input EnvironmentCreateInput {
  ephemeral: Boolean
  name: String!
  projectId: String!
  "When committing the changes immediately, skip any initial deployments."
  skipInitialDeploys: Boolean
  "Create the environment with all of the services, volumes, configuration, and variables from this source environment."
  sourceEnvironmentId: String
  "Stage the initial changes for the environment. If false (default), the changes will be committed immediately."
  stageInitialChanges: Boolean
}
input EnvironmentRenameInput {
  name: String!
}
input EnvironmentTriggersDeployInput {
  environmentId: String!
  projectId: String!
  serviceId: String!
}
input EventBatchTrackInput {
  events: [EventTrackInput!]!
}
input EventFilterInput {
  action: EventStringListFilter
  object: EventStringListFilter
}
input EventStringListFilter {
  in: [String!]
  notIn: [String!]
}
input EventTrackInput {
  eventName: String!
  properties: EventProperties
  ts: String!
}
input ExplicitOwnerInput {
  "The ID of the owner"
  id: String!
  "The type of owner"
  type: ResourceOwnerType!
}
input FeatureFlagToggleInput {
  flag: ActiveFeatureFlag!
}
input GitHubRepoDeployInput {
  branch: String
  projectId: String!
  repo: String!
}
input GitHubRepoUpdateInput {
  environmentId: String!
  projectId: String!
  serviceId: String!
}
input HelpStationFormInput {
  isPrivate: Boolean!
  message: String!
  subject: String!
  topic: String!
}
input HerokuImportVariablesInput {
  environmentId: String!
  herokuAppId: String!
  projectId: String!
  serviceId: String!
}
input IntegrationCreateInput {
  config: JSON!
  integrationAuthId: String
  name: String!
  projectId: String!
}
input IntegrationUpdateInput {
  config: JSON!
  integrationAuthId: String
  name: String!
  projectId: String!
}
input JobApplicationCreateInput {
  email: String!
  jobId: String!
  name: String!
  why: String!
}
input LoginSessionAuthInput {
  code: String!
  hostname: String
}
input MissingCommandAlertInput {
  page: String!
  text: String!
}
input ObservabilityDashboardCreateInput {
  environmentId: String!
  "If no items are provided, a default dashboard will be created."
  items: [ObservabilityDashboardUpdateInput!]
}
input ObservabilityDashboardItemConfigInput {
  logsFilter: String
  measurements: [MetricMeasurement!]
  projectUsageProperties: [ProjectUsageProperty!]
  resourceIds: [String!]
}
input ObservabilityDashboardItemCreateInput {
  config: ObservabilityDashboardItemConfigInput!
  description: String
  id: String!
  name: String!
  type: ObservabilityDashboardItemType!
}
input ObservabilityDashboardUpdateInput {
  dashboardItem: ObservabilityDashboardItemCreateInput!
  displayConfig: DisplayConfig!
  id: String!
}
input PluginCreateInput {
  environmentId: String
  friendlyName: String
  name: String!
  projectId: String!
}
input PluginRestartInput {
  environmentId: String
}
input PluginUpdateInput {
  friendlyName: String!
}
input PreferencesUpdateData {
  buildFailedEmail: Boolean
  changelogEmail: Boolean
  communityEmail: Boolean
  deployCrashedEmail: Boolean
  ephemeralEnvironmentEmail: Boolean
  marketingEmail: Boolean
  subprocessorUpdatesEmail: Boolean
  token: String
  usageEmail: Boolean
}
input PrivateNetworkCreateOrGetInput {
  environmentId: String!
  name: String!
  projectId: String!
  tags: [String!]!
}
input PrivateNetworkEndpointCreateOrGetInput {
  environmentId: String!
  privateNetworkId: String!
  serviceId: String!
  serviceName: String!
  tags: [String!]!
}
input ProjectCreateInput {
  defaultEnvironmentName: String
  description: String
  isPublic: Boolean
  name: String
  plugins: [String!]
  prDeploys: Boolean
  repo: ProjectCreateRepo
  runtime: PublicRuntime
  teamId: String
}
input ProjectCreateRepo {
  branch: String!
  fullRepoName: String!
}
input ProjectInviteUserInput {
  email: String!
  link: String!
}
input ProjectInvitee {
  email: String!
  role: ProjectRole!
}
input ProjectMemberRemoveInput {
  projectId: String!
  userId: String!
}
input ProjectMemberUpdateInput {
  projectId: String!
  role: ProjectRole!
  userId: String!
}
input ProjectTokenCreateInput {
  environmentId: String!
  name: String!
  projectId: String!
}
input ProjectTransferConfirmInput {
  ownershipTransferId: String!
  projectId: String!
}
input ProjectTransferInitiateInput {
  memberId: String!
  projectId: String!
}
input ProjectTransferToTeamInput {
  teamId: String!
}
input ProjectUpdateInput {
  baseEnvironmentId: String
  "Enable/disable pull request environments for PRs created by bots"
  botPrEnvironments: Boolean
  description: String
  isPublic: Boolean
  name: String
  prDeploys: Boolean
}
input RecoveryCodeValidateInput {
  code: String!
  twoFactorLinkingKey: String
}
input ReferralInfoUpdateInput {
  code: String!
}
"Private Docker registry credentials. Only available for Pro plan deployments."
input RegistryCredentialsInput {
  password: String!
  username: String!
}
input ResetPluginCredentialsInput {
  environmentId: String!
}
input ResetPluginInput {
  environmentId: String!
}
input SendCommunityThreadNotificationEmailInput {
  threadTitle: String!
  threadUrl: String!
  userIds: [String!]!
}
input ServiceConnectInput {
  "The branch to connect to. e.g. 'main'"
  branch: String
  "Name of the Dockerhub or GHCR image to connect this service to."
  image: String
  "The full name of the repo to connect to. e.g. 'railwayapp/starters'"
  repo: String
}
input ServiceCreateInput {
  branch: String
  "Environment ID. If the specified environment is a fork, the service will only be created in it. Otherwise it will created in all environments that are not forks of other environments"
  environmentId: String
  icon: String
  name: String
  projectId: String!
  registryCredentials: RegistryCredentialsInput
  source: ServiceSourceInput
  templateServiceId: String
  variables: ServiceVariables
}
input ServiceDomainCreateInput {
  environmentId: String!
  serviceId: String!
  targetPort: Int
}
input ServiceDomainUpdateInput {
  domain: String!
  environmentId: String!
  serviceDomainId: String
  serviceId: String!
  targetPort: Int
}
input ServiceFeatureFlagToggleInput {
  flag: ActiveServiceFeatureFlag!
  serviceId: String!
}
input ServiceInstanceLimitsUpdateInput {
  environmentId: String!
  "Amount of memory in GB to allocate to the service instance"
  memoryGB: Int
  serviceId: String!
  "Number of vCPUs to allocate to the service instance"
  vCPUs: Int
}
input ServiceInstanceUpdateInput {
  buildCommand: String
  builder: Builder
  cronSchedule: String
  healthcheckPath: String
  healthcheckTimeout: Int
  nixpacksPlan: JSON
  numReplicas: Int
  railwayConfigFile: String
  region: String
  registryCredentials: RegistryCredentialsInput
  restartPolicyMaxRetries: Int
  restartPolicyType: RestartPolicyType
  rootDirectory: String
  sleepApplication: Boolean
  source: ServiceSourceInput
  startCommand: String
  watchPatterns: [String!]
}
input ServiceSourceInput {
  image: String
  repo: String
}
input ServiceUpdateInput {
  icon: String
  name: String
}
input SharedVariableConfigureInput {
  disabledServiceIds: [String!]!
  enabledServiceIds: [String!]!
  environmentId: String!
  name: String!
  projectId: String!
}
input TCPProxyCreateInput {
  applicationPort: Int!
  environmentId: String!
  serviceId: String!
}
input TeamBulkProjectTransferInput {
  projectIds: [String!]!
  teamId: String!
}
input TeamCreateAndSubscribeInput {
  avatar: String
  name: String!
  paymentMethodId: String!
}
input TeamCreateInput {
  avatar: String
  name: String!
}
input TeamInviteCodeCreateInput {
  role: String!
}
input TeamPermissionChangeInput {
  role: TeamRole!
  teamId: String!
  userId: String!
}
input TeamUpdateInput {
  avatar: String
  name: String!
}
input TeamUserInviteInput {
  code: String!
  email: String!
}
input TeamUserRemoveInput {
  userId: String!
}
input TelemetrySendInput {
  command: String!
  environmentId: String
  error: String!
  projectId: String
  stacktrace: String!
  version: String
}
input TemplateCloneInput {
  code: String!
  teamId: String
}
input TemplateCreateInput {
  canvasConfig: CanvasConfig
  config: TemplateConfig!
  demoProjectId: String
  metadata: TemplateMetadata!
  services: [TemplateServiceCreateInput!]!
  teamId: String
}
input TemplateDeleteInput {
  teamId: String
}
input TemplateDeployInput {
  environmentId: String
  projectId: String
  services: [TemplateDeployService!]!
  teamId: String
  templateCode: String
}
input TemplateDeployService {
  commit: String
  hasDomain: Boolean
  healthcheckPath: String
  id: String!
  isPrivate: Boolean
  name: String
  owner: String
  rootDirectory: String
  serviceIcon: String
  serviceName: String!
  startCommand: String
  tcpProxyApplicationPort: Int
  template: String!
  variables: ServiceVariables
  volumes: [TemplateVolume!]
}
input TemplateGenerateInput {
  projectId: String!
  teamId: String
}
input TemplatePublishInput {
  category: String!
  demoProjectId: String
  description: String!
  image: String
  readme: String!
  teamId: String
}
input TemplateServiceCreateInput {
  config: TemplateServiceConfig!
}
input TemplateServiceSourceEjectInput {
  projectId: String!
  repoName: String!
  repoOwner: String!
  "Provide multiple serviceIds when ejecting services from a monorepo."
  serviceIds: [String!]!
  upstreamUrl: String!
}
input TemplateServiceUpdateInput {
  config: TemplateServiceConfig!
  id: String
}
input TemplateUpdateInput {
  canvasConfig: CanvasConfig
  config: TemplateConfig!
  demoProjectId: String
  "An admin-only flag to force-update a template."
  forceUpdate: Boolean = false
  metadata: TemplateMetadata!
  services: [TemplateServiceUpdateInput!]!
  teamId: String
}
input TwoFactorInfoCreateInput {
  token: String!
}
input TwoFactorInfoValidateInput {
  token: String!
  twoFactorLinkingKey: String
}
input UsageLimitRemoveInput {
  customerId: String!
}
input UsageLimitSetInput {
  customerId: String!
  hardLimitDollars: Int
  softLimitDollars: Int!
}
input UserFlagsRemoveInput {
  flags: [UserFlag!]!
  userId: String
}
input UserFlagsSetInput {
  flags: [UserFlag!]!
  userId: String
}
input UserProfileUpdateInput {
  bio: String
  isPublic: Boolean!
  website: String
}
input UserUpdateInput {
  avatar: String
  name: String
  username: String
}
input VariableCollectionUpsertInput {
  environmentId: String!
  projectId: String!
  "When set to true, removes all existing variables before upserting the new collection."
  replace: Boolean = false
  serviceId: String
  variables: ServiceVariables!
}
input VariableDeleteInput {
  environmentId: String!
  name: String!
  projectId: String!
  serviceId: String
}
input VariableUpsertInput {
  environmentId: String!
  name: String!
  projectId: String!
  serviceId: String
  value: String!
}
input VolumeCreateInput {
  "The environment to deploy the volume instances into. If `null`, the volume will not be deployed to any environment. `undefined` will deploy to all environments."
  environmentId: String
  "The path in the container to mount the volume to"
  mountPath: String!
  "The project to create the volume in"
  projectId: String!
  "The service to attach the volume to. If not provided, the volume will be disconnected."
  serviceId: String
}
input VolumeInstanceUpdateInput {
  "The mount path of the volume instance. If not provided, the mount path will not be updated."
  mountPath: String
  "The service to attach the volume to. If not provided, the volume will be disconnected."
  serviceId: String
  "The state of the volume instance. If not provided, the state will not be updated."
  state: VolumeState
}
input VolumeUpdateInput {
  "The name of the volume"
  name: String
}
input WebhookCreateInput {
  projectId: String!
  url: String!
}
input WebhookUpdateInput {
  url: String!
}
input customerTogglePayoutsToCreditsInput {
  isWithdrawingToCredits: Boolean!
}
"Exposes a URL that specifies the behavior of this scalar."
directive @specifiedBy(
    "The URL that specifies the behavior of this scalar."
    url: String!
  ) on SCALAR
